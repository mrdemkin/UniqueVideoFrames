import numpy as Nump
from PIL import Image, ImageDraw #, ImageFont
import cv2

# subtitle_add_str = 'Dialogue: 0,0:00:' + timelapse + '.00,0:00:' + timelapse_next + '.00,Default,,0,0,0,,' + platform + ' FPS: ' + fps_counter_on_screen
subtitle_ass_base = '[Script Info]\n; Script generated by FFmpeg/Lavc58.6.101\nScriptType: v4.00+\nPlayResX: 384\nPlayResY: 288\n\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default,Arial,16,&Hffffff,&Hffffff,&H0,&H0,0,0,0,0,100,100,0,0,1,1,0,2,10,10,10,0\n\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n'
ffmpeg_path = ''
frames_in_name = 8
current_frame_name = 'images'
current_frame_extension = '.png'
resize_to = 32
progressive_scan = True


class FrameInfo():
    time = 0
    frame_index = 0
    is_have_tearing = False


class SecondInfo ():
    framerate = 0
    # need frames info with objest of FrameInfo
    second_index = 0
    frames = []
    
class FrameCounter:
    def __init__(self, ffmpeg_path, progressive_scan):
        self.ffmpeg_path = ffmpeg_path
        self.progressive_scan = progressive_scan


    def compare_two_frames(file1, file2, path1, path2):
        im = [None, None]
        blockSize = 101
        c = 5
        blurSize = 3
        for i, f in enumerate([path1, path2]):
            im[i] = (Nump.array(Image.open(f)
                                .convert('L')  #Grayscale
                                .resize((resize_to, resize_to), resample=Image.BICUBIC))
                     ).astype(Nump.int)
        delta = im[0].sum() * 0.008 #nice for 720p
        if progressive_scan is False:
            delta = im[0].sum() * 0.016 #for n64 720i
        difference_value = Nump.abs(im[0] - im[1]).sum()
        if difference_value > delta:
            return 2
        else:
            return 0
        #TODO: set return boolean value


    def get_right_zeros_name(cur_file_name):
        global frames_in_name
        if (len(cur_file_name) < frames_in_name):  # for right frame-file name
            zeros = frames_in_name - len(cur_file_name)  # check for current zeros in name
            for cur_zero in range(zeros):
                cur_file_name = '0' + cur_file_name  # add zeros to name for search it
        return cur_file_name


    def open_save_file():
        f = open(ffmpeg_path.replace('ffmpeg.exe', '') + 'savefile.json', "w")
        f.write('{"seconds" : {\n')
        # f.close()


    def add_second_to_save_file(new_second_info):
        f = open(ffmpeg_path.replace('ffmpeg.exe', '') + 'savefile.json', "a")
        f.write('"second_' + str(new_second_info.second_index) + '" : {"framerate" : ' + str(new_second_info.framerate) + ', "frametimes" : [' + ','.join(str(e) for e in new_second_info.frames) + ']},\n')
        # circle for frames


    def close_save_file():
        f = open(ffmpeg_path.replace('ffmpeg.exe', '') + 'savefile.json', "a")
        # maybe need add ; ? And remove last , ?
        f.write('\n}\n}')
        f.close()


    def timelapse_string(cur_second_index):
        if cur_second_index > 9:
            timelapse = str(cur_second_index)
        else:
            timelapse = '0' + str(cur_second_index)
        return timelapse

    def print_current_second_in_terminal(timelapse, framerate):
        print (timelapse + " second: framerate = " + str(framerate))


    def save_subtitle_file(subtitle_ass_base):
        f = open(ffmpeg_path.replace('ffmpeg.exe', '') + 'subtitle.ass', "w")
        f.write(subtitle_ass_base)
        f.close()


    def count_framerate(equal_point_for_compare, temp_dir, framerate, seconds, platform):
        #old code here, will be added
